| 1 | 2 | 3 |
-------------
| 4 | 5 | 6 |
-------------
| 7 | 8 | 9 |
-------------
1. 对于上面的n*m(3*3)的格子，有两种情况
a. 如果n或者m为1，则只有一行或者一列，从左上角走到右下角的路径数为n + m
比如： 1 * 1格子，可以先向下走，再向右走，到达右下角；或者先向右走，
再向下走，到达右下角，共两条，即 1 + 1 = 2，对于1 * m和 n * m的
情况同学们自己画一下
b. 如果n,m都大于1，那么走到[n][m]格子的右下角只有两条路径，
<1>: 从[n - 1][m]格子的右下角向下走，到达
<2>: 从[n][m - 1]格子的右下角向右走，到达
所以走到[n][m]格子的右下角的数量为[n-1][m] + [n][m - 1],可以通过递归实现，情况a为
递归的终止条件。
#include<iostream>
using namespace std;
int pathNum(int n,int m)
{
if(n > 1 && m > 1)
//b情况，递归
return pathNum(n-1,m) + pathNum(n,m-1);
else if(((n >= 1)&&(m == 1))||((n == 1)&&(m >= 1)))
// a情况，终止条件
return n + m;
else
//格子为0时， 路径为0
return 0;
}
int main()
{
int n,m;
while(cin>>n>>m)
{
cout<<pathNum(n,m)<<endl;
}
return 0;
}