**C++引用**

**概念：**
  引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。

**特性：**
1. 引用在定义时必须初始化
2. 一个变量可以有多个引用
3. 引用一旦引用一个实体，再不能引用其他实体

**常引用：**
void TestConstRef()
{
const int a = 10;
//int& ra = a; // 该语句编译时会出错，a为常量
const int& ra = a;
// int& b = 10; // 该语句编译时会出错，b为常量
const int& b = 10;
double d = 12.34;
//int& rd = d; // 该语句编译时会出错，类型不同
const int& rd = d;
}

**应用场景：**
1.作为函数的参数：
  1.1 需要通过形参改变外部实参 T&
  1.2 不需要通过形参改变外部实参 const T&
2.作为函数的返回值：注意不能返回函数栈上的空间
  只要返回值的生命周期不受函数控制（函数结束后不影响变量的生命周期）
  1.全局变量
  2.static类型的变量
  3.返回引用类型的变量
  
**引用与指针**

#include<iostream>
using namespace std;

int main() {
	int a = 10,b=20;

	int* pa = &a;
	*pa = 20;

	int& rb = b;//引用在底层实际就是按照指针的方式进行处理的。
	rb = 20;//实际上：引用类型的变量也有空间，空间中实际存放的是引用实体的地址

	return 0;
}

引用和指针的不同点:
1. 引用在定义时必须初始化，指针没有要求
2. 引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型
实体
3. 没有NULL引用，但有NULL指针
4. 在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占
4个字节)
5. 引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小
6. 有多级指针，但是没有多级引用
7. 访问实体方式不同，指针需要显式解引用，引用编译器自己处理
8. 引用比指针使用起来相对更安全